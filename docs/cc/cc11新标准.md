---
id: cc-11-new-standard
title: 'C++11 新标准'
sidebar_label: "C++11 新标准"
---
## 新类型
C++11新增了类型 `long long` 和 `unsigned long long`，以支持64位或是更宽的整形

还新增了 `char16_t` 和 `char32_t`，以支持16位和32位的字符表示

新增了“原始”字符串

---
## 统一的初始化
C++11扩大了初始化列表的适用范围，使其可以用于所有内置类型和用户定义的类型（即类与对象）。使用初始化列表时，可以添加 `=` 符，也可以不加

``` cpp title="eg."
int x = {5};
double y {2.75};
short quar[5] {4, 5, 2, 76, 1};
```

初始化列表语法也可用于 `new` 表达式中
``` cpp title="eg."
int * ar = new int [4] {2, 4, 6, 7};
```

创建对象时，也可使用初始化列表来调用构造函数
``` cpp title="eg."
class Student{
private:
    int age;
    double height;
public:
    Student (int a, double h) : age(a), height(h){
    
    }
};
int main() {
    Student s1(18, 170.25);  // old style
    Student s2{19, 175.86};  // C++11
    Student s3 = {20, 180.09};  // C++11
}
```

### 防止缩窄
初始化列表语法可防止缩窄，即禁止将数值赋给无法储存它的数值变量
``` cpp title="eg."
// 常规初始化允许执行可能没有意义的操作
char c1 = 1.57e27;  // double to char
char c2 = 459585821;  // int to char. out of range
```

如果使用初始化列表语法，编译器将禁止进行这样的类型转换
``` cpp title="eg."
// compile error
char c1 {1.57e27};  // double to char
char c2 = {459585821};  // int to char. out of range
```

但是允许转换为更宽的类型，或是值在较窄类型的取值范围内，也允许转换为较窄的类型
``` cpp title="eg."
// allow
char c1 {66};  // int to char. in range
double c2 = {66};  // int to double
```

### std::initializer_list

C++11提供了模板类 `initializer_list`，可将其用作构造函数的参数。如果有类接受  `initializer_list`作为参数的构造函数，则初始化列表语法就只能用于该构造函数。

`STL` 的 `vector` 类提供了将  `initializer_list` 作为参数的构造函数
``` cpp title="eg."
vector<int> v1(10); // v1为有10个元素的为初始化容器
vector<int> v2{10}; // v2为有1个元素值为10的容器
vector<int> v3{4, 6, 1}; // v3 3个元素为 4，6，1
```

头文件 `initializer_list` 提供了对类模板  `initializer_list`，这个类包含成员`brgin()` 和`end()`，用于获取列表范围

除用于构造函数外， `initializer_list` 还可用作常规函数的参数
``` cpp title="eg."
#include<initializer_list>
double sum(std::initializer_list<double> il){
    double num = 0;
    for (auto i = il.begin(); i != il.end(); i++) {
        num += *i;
    }
    return num;
}
```
- 这里用到了 **`auto`** 来简化代码声明
---
## 声明
**C++11** 提供了多种简化声明的功能，尤其在使用模板时
### auto
在 **C++98** 中，关键字 **`auto`** 是一个存储类型说明符，**C++11** 将其用于实现自动类型推断

在初始化声明中，如果使用关键字 **`auto`**，而不指定变量类型，编译器将把变量的类型设置成与初始值相同
``` cpp title="eg."
auto n = 100; // int
auto x = 1.5; // double
auto y = 1.3e12L // long double
```
- **auto 变量必须在定义时初始化**

但是 **`auto`** 并不是为了这种简单的情况设计的，处理复杂类型时，才能体现 **`auto`** 的优势

例如标准库模块（STL）中的类型
``` cpp title="eg."
// C++98
std::vector<double> scores;
std::vector<double>::iterator pv = scores.begin();
// C++11 允许以如下方式重写
std::vector<double> scores;
auto pv = scores.begin();
```
**`auto`** 用于定义模板函数

例如定义一个求乘积的函数模板
``` cpp title="eg."
template <typename T1,typename T2>
void Multiply(T1 x, T2 y) {
    auto result = x * y;
    std::cout << result;
}
```  
- 如果没有 **`auto`** **result** 的类型定义将会变得很繁琐

### decltype
关键字 **`decltype`** 将变量的类型声明为表达式指定的类型 **`decltype(x) y;`**
``` cpp title="eg."
int n;
double x;
decltype(x * n) y; // double
decltype(&x) z; // double *
```
根据使用的表达式，指定的类型可以为引用和 **`const`**
``` cpp title="eg."
int i = 3;
int &k = i;
const int &n = i;
decltype(n) j1; // const int &
decltype(i) j2; // int
decltype((i)) j3; // int &
decltype(k + 1) j4; // int
```

在定义模板时 **`decltype`** 将会很有用，因为模板要在实例化时才能确定类型
``` cpp
template<typename T1, typename T2>
void func(T t1, U t2){
    decltype(t1 * t2) t;
    // code
}
```

### 后置返回类型
**C++11** 新增了一种函数声明语法 —— 在函数名和参数列表后面指定返回类型
``` cpp
int(int x, int y);
auto func(int x, int y) -> int;
```

用 **`decltype`** 来指定模板函数的返回类型
``` cpp
template <typename T1,typename T2>
auto Multiply(T1 x, T2 y) -> decltype(T1 * T2) {
    return x * y;
}
```

### 模板别名：using=
对于冗长或复杂的标识符，C++提供了 **`typedef`** 来创建别名
``` cpp
typedef std::vector<std::string>::iterator itType;
```

但是**typedef**不能用于模板，C++11提供了另一种创建别名的关键字 **`using`** 
``` cpp
using itType = std::vector<std::string>::iterator;
```

**`using`** 用于模板部分具体化

对于如下声明
``` cpp
std::array<double, 12> a1;
std::array<std::string, 12> a2;
```
可使用 **`using`** 具体化模板 **`array<T, int>`** —— 将**int**参数设置为12
``` cpp
template<typename T>
using arr12 = std::array<T, 12>; // array 别名
arr12<double> a1;
arr12<std::string> a2;
```

### nullptr
#### `NULL`、`nullptr`、`0` 的区别
**NULL**的定义
``` cpp
#ifndef __cplusplus
#define NULL ((void *)0)
#else   /* C++ */
#define NULL 0
```
在C++中，**NULL**被直接定义为 **`0`**，这样在函数重载时用**NULL**表示空指针则会出现问题
``` cpp
void function(int a, int *pb);    // 原函数
void function(int a, int pb);    // 重载
function(a, NULL);
```
也就是说**NULL**在程序中具有二义性，C++11引入了 **`nullptr`** 关键字来代指空指针

**`nullptr`** 是指针类型，不能转换为整型，但是C++11仍热允许使用 **`0`** 来表示空指针， 因此 **`nullptr == 0`** 为 **true**，但是使用 **nullptr** 会有更高的安全性

## [智能指针](#智能指针)
如果在程序中使用 **`new`** 从堆（自由存储区）中分配内存，等到不需要的时候，应该使用 **`delete`** 将其释放，C++引入了智能指针 **`auto_ptr`**，但是在**C++11**中新增了三种有更精致机制的智能指针 **`unique_ptr`**、**`shared_ptr`**、**`weak_ptr`**，并摒弃了 **`auto_ptr`**

## 关于异常规范的修改
C++提供了一种语法，可用于指出那些函数可能引发哪些异常
``` cpp
void f501(int) throw(bad_dog); // 可能抛出 bad_dog 异常
void f733(long long) throw(); // 不会抛出异常
```
标准委员会认为，指出函数不会引发异常有一定的价值，为此添加了关键字 **`noexcept`**
``` cpp
void f875(short, short) noexcept; // 不会抛出异常
```

## 作用域内枚举